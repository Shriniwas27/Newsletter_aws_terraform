Production-Grade FastAPI Deployment on AWS with TerraformThis project provides a complete, production-grade infrastructure as code (IaC) setup to deploy a highly available, scalable, and secure FastAPI application on Amazon Web Services (AWS) using Terraform.The architecture is designed following industry best practices to be robust and resilient, suitable for a real-world production workload.Architecture Deep DiveBefore we look at the code, it's crucial to understand the components and the flow of traffic. This isn't just a collection of services; it's a carefully designed system where each part has a specific role.(This is where you can insert a screenshot of the architecture diagram)The Journey of a RequestLet's trace the path of a user's request from their browser to our database and back:DNS Resolution (Route 53): The user types https://www.your-domain.com into their browser. The request first hits Amazon Route 53, which acts as the internet's phonebook. It looks up your domain and points the user to your CloudFront distribution.Edge Layer (CloudFront & WAF): The request arrives at the nearest AWS edge location.AWS WAF inspects the request first, checking for malicious patterns like SQL injection or XSS. If the request is malicious, it's blocked immediately.CloudFront then checks if it has a cached copy of the requested page. If it does (a "cache hit"), it serves the page directly from the edge location with extremely low latency. If not (a "cache miss"), it forwards the request to the origin.Load Balancing (ALB): The request travels from CloudFront to our Application Load Balancer in the us-east-1 region. The ALB's job is to terminate the request and intelligently distribute it to one of the healthy EC2 instances. It operates in two Availability Zones, so if one instance or even an entire AZ is down, it seamlessly routes traffic to the healthy ones.Compute Layer (EC2): The request arrives at one of our EC2 instances running in a private subnet. Our FastAPI application, managed by a Uvicorn server, processes the request.Database Interaction (RDS):If the request requires reading data (e.g., loading the list of items), the application is configured to send the SQL query to the RDS Read Replica. This keeps the primary database free to handle writes.If the request requires writing data (e.g., submitting the form to add a new item), the application sends the query to the primary RDS Writer Instance.The Response Journey: The response travels back along the same path: from the EC2 instance to the ALB, from the ALB to CloudFront (which may cache the response for future requests), and finally back to the user's browser.Why This Design?Security by Isolation: The most critical components—our application servers and database—are in private subnets. This is the cornerstone of our security model. It means there is no possible way for a user on the internet to connect directly to them. The only way in is through the controlled, monitored, and firewalled path we've created.Availability Through Redundancy: By deploying our ALB, EC2 instances, and RDS instances across two Availability Zones, we have no single point of failure. The failure of any single component will not take down the entire application.Performance Through Distribution: We distribute the load in two ways: CloudFront distributes the load globally, and the ALB distributes the load regionally across our servers. The read replica further distributes the database load, separating read and write concerns.Services UsedThis project orchestrates a number of AWS services and Terraform providers to build the complete architecture.AWS ServicesVPC (Virtual Private Cloud): The networking foundation, providing an isolated virtual network for all our resources.EC2 (Elastic Compute Cloud): The virtual servers that run our FastAPI application code.Auto Scaling Group: Manages the EC2 instances, ensuring the desired number of servers are always running and healthy.RDS (Relational Database Service): A managed PostgreSQL database service, which we deploy in a primary/replica configuration for performance and high availability.Application Load Balancer (ALB): A Layer 7 load balancer that distributes incoming HTTP/S traffic to our EC2 instances.Route 53: AWS's managed DNS service, used to route traffic for our custom domain to the CloudFront distribution.ACM (AWS Certificate Manager): Provides free public SSL/TLS certificates to enable HTTPS on our custom domain.CloudFront: A global Content Delivery Network (CDN) that caches our content at edge locations, reducing latency for users and offloading traffic from our origin.WAF (Web Application Firewall): A firewall that protects our application from common web exploits.Secrets Manager: A secure service for storing and retrieving secrets like our database password.CloudWatch: A suite of monitoring services. We use it for collecting logs (CloudWatch Logs) and triggering alerts (CloudWatch Alarms).SNS (Simple Notification Service): A messaging service used to send email notifications when our CloudWatch alarms are triggered.IAM (Identity and Access Management): Manages permissions, allowing our EC2 instances to securely access other AWS services without hardcoded credentials.Terraform Providershashicorp/aws: The official provider for interacting with all the AWS services listed above.hashicorp/random: A utility provider used to generate a strong, random password for our RDS database.Required User Changes (Before You Apply!)Before running terraform apply, you must customize a few files to match your environment.1. variables.tfOpen this file and set the following values:notification_email: Change the default value to your own email address. This is where you will receive monitoring alerts.create_dns_and_cdn: This is the most important setting.If you do not have a domain name, leave this as false.If you do have a domain name, change this to true.domain_name: If you set the above to true, change this to your registered domain name (e.g., "buildownstuff.fun").2. ec2.tfOpen this file and find the user_data section inside the aws_launch_template resource.Update the GitHub URL: Change the git clone command to point to your application code repository if you are using a different one.# ... inside user_data ...
git clone https://github.com/YOUR_USERNAME/YOUR_REPO.git /home/ubuntu/repo
# ...

Deployment GuideFollow these steps to deploy the entire stack from your local machine.PrerequisitesAn AWS Account.Terraform installed.The AWS CLI installed and configured with your credentials (aws configure).Git installed.(Optional) A registered domain name.Step 1: Clone the Infrastructure RepositoryFirst, clone this Terraform repository to your local machine.git clone https://github.com/Shriniwas27/Newsletter_aws_terraform.git
cd Newsletter_aws_terraform

Step 2: Make the Required ChangesOpen the project in your favorite editor and make the necessary changes in variables.tf and ec2.tf as described in the "Required User Changes" section above.Step 3: Initialize TerraformThis command downloads the necessary provider plugins. You only need to run this once.terraform init

Step 4: Review the Deployment PlanThis is a dry run that shows you every AWS resource Terraform will create. Always review this carefully.terraform plan

Step 5: Apply and Build!This command builds the entire infrastructure. It will take several minutes (15-20 minutes is common).terraform apply

Terraform will show you the plan again and ask for one final confirmation. Type yes and press Enter.(This is where you can insert a screenshot of the terraform apply output)Step 6: Post-Deployment StepsOnce the apply command is complete, you will see a list of outputs.If you deployed without a domain:Look for the application_access_point output. This is the public DNS name of your Application Load Balancer.Wait about 5-10 minutes for the EC2 instances to finish their startup script.You can then access your application by pasting this URL into your browser (make sure to use http).If you deployed with a domain:Look for the route53_nameservers output. It will be a list of four AWS nameserver addresses.You must log in to your domain registrar (e.g., Freenom, GoDaddy) and change your domain's nameservers to these four values.Wait for DNS propagation (this can take up to 48 hours, but is usually much faster).Once propagation is complete, you can access your application at your custom domain: https://www.your-domain.com.(This is where you can insert a screenshot of your domain registrar's nameserver settings)Managing the InfrastructureApplying Changes: Any time you make a change to a .tf file, simply run terraform apply again. Terraform will intelligently figure out what needs to be added, changed, or deleted.Destroying the Infrastructure: To cleanly delete all the resources you've created and avoid ongoing costs, run:terraform destroy

